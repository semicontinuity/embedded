CAN Protocol
================================================================================

Requirements
--------------------------------------------------------------------------------

The CAN protocol is designed to fulfill the following requirements:

- Support for multiple physical buses and routing.
- Possibility to debug system behaviour by analyzing bus traffic.
- Support messages addressed to a group of nodes (multicast).
- Nodes should provide information about themselves and their capabilities.
- Compatibility with Microchip CAN Extenders.


Design decisions
--------------------------------------------------------------------------------

Supported message types:
    - Information request message (also referred to as RTR or Query)
    - Output message, i.e. the message transmitted from the node with some payload.
      Can be initiated by the node itself (notification)
      or in response to information request message.
    - Input message, i.e. the message transmitting payload to the node.
    - Error message, that signals that Input message was rejected.

Only extended messages are supported,
to have long enough headers that have all the necessary fields.

Message headers contain addresses of both the sender and the receiver
of the message, to simplify system debugging by logging of all traffic.

To simplify software, no distinction is made between responses
to RTR and node-initiated notifications.
If the node is able to send notifications, an RTR will make the node
transmit a notification, as if the condition to transmit the notification
was met.

For compatibility with CAN extenders, RTR and RTR response messages
have the same ID bits (the only difference is in RTR bit and payload).
Thus, there are no fields like 'sender address' and 'receiver address'
in the header, but 'host address', 'counterparty address' and 'owner'.
It also makes the node software simpler: to generate the response to RTR,
it is only necessary to clear RTR bit
(but the router software is becoming more complex).

There is no field in the message to tell that the message is addressed to a group.
Certain ranges of addresses should be allocated to multicasts,
and a router, if present, should be consistent with the chosen address scheme.



Message header layout
--------------------------------------------------------------------------------

SID10 ..     SID3 SID2..0 IDE EID17 EID15  ..    EID8 EID7    ..   EID0
+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
|10            3| |2 1 0| |1| |   | |               | |               |
+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
|  Long Tag - 11 bits   |           |  Parameter (16 bits)            |
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
|short|   cpty  | | cpty|     |o|a| | host| host    | | slot          |
| tag | address | | net |     |w|u| |  net| address | |               |
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+

- Parameter (16 bit): A virtual address, assigned to the 8-byte data item (parameter's value).
  Consists of:
  - host subnet and address: identifies the CAN node that hosts the addressed slot.
  - slot: identifies a parameter within the node.


- Short tag (3 bits): used to tag the specific type of traffic. also specifies the priority of the current message.
- Counterparty subnet and address: identifies the node, that is a counterparty in the current transaction.
  A couterparty is a sender of Input or Query message, or a recipient of Output or Error message.
  A system can be designed without the use of counterparty addresses,
  but it comes in handy when debugging a system (e.g. to identify the node that has sent a message),
  and also for networks with a router.

  In a single-master systems, contains the address of the master.
  Can be omitted to extend the Tag to 11 bits (Long Tag).

- Owner (1 bit): Set for a packet with the payload, transmitted by the owner of the parameter (from the owner to the client)
                 Reset for a packet with the payload, transmitted by the non-owner of the parameter (from the client to the owner)

- Auxillary: Auxillary bit, for now used to distinguish SYSTEM (1) and USER (0) messages.

The combination of Auxillary, RTR and Owner bits defines the message type:

- AUX=0, RTR=0, OWN=0:  PUT request, the client asks the node to set the certain parameter.
- AUX=0, RTR=0, OWN=1:  Parameter VALUE, sent by the parameter owner. Either the response to PUT or the owner-initiated notification.
- AUX=0, RTR=1, OWN=0:  NOT_OK response to PUT.
- AUX=0, RTR=1, OWN=1:  GET request, the client asks the node to send out the value of a certain parameter.

The router must examine RTR and OWNER bits, to identify the destination network of the packet.

Each node has a virtual memory space, that can be read or written remotely.
As the maximum payload of CAN message is 8 bytes,
the addresses used in read and write operations are aligned to 8-byte boundaries.
The 8-byte piece of memory is called a Slot.
Memory operations are using slot numbers instead of memory addresses.

In total, there are 9 bits in the message header for the slot number:
1 bit of AUX + 8 bits of SLOT, so there are 512 slots per node.
The lower 256 slots (AUX=0) are dedicated for user memory, and the higher 256 (AUX=1) for system memory.


Message header layout examples
--------------------------------------------------------------------------------

Client node 001.00001 sets the value of the parameter 010.00010.00000:

 0 1 1 0 0 0 0 1   0 0 1   0   0 0   0 1 0 0 0 0 1 0   0 0 0 0 0 0 0 0  (RTR=0: payload)
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
|short|   cpty  | | cpty|  R  |o|a| | host| host    | | slot          |
| tag | address | | net |     |w|u| |  net| address | |               | 
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
Router sees that RTR==0 && Owner==0 => destination net is host net



Query for the value of the parameter 010.00010.00000 from the node 001.00001:

 0 1 1 0 0 0 0 1   0 0 1   1   1 0   0 1 0 0 0 0 1 0   0 0 0 0 0 0 0 0  (RTR=1: no payload)
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
|short|   cpty  | | cpty|  R  |o|a| | host| host    | | slot          |
| tag | address | | net |     |w|u| |  net| address | |               | 
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
Router sees RTR==1 => destination net is host net
Owner bit is set to 1 so that query and response headers are the same (to use CAN extender chips)
If RTR==1 && Owner==0 => semantics undefined yet (
  e.g: notification to client(s) to invalidate their local copies of the specified parameter?
  e.g: (non) acknowledgement of the reception of the new value of the parameter
)


The node 010.00010 replies to the node 001.00001 with the value of the parameter 010.00010.00000
(or sends notification):

 0 1 1 0 0 0 0 1   0 0 1   0   1 0   0 1 0 0 0 0 1 0   0 0 0 0 0 0 0 0  (RTR=0: payload)
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
|short|   cpty  | | cpty|  R  |o|a| | host| host    | | slot          |
| tag | address | | net |     |w|u| |  net| address | |               | 
+-----+---------+ +-----+     +-+-+ +-----+---------+ +---------------+
Router sees RTR==0 && Owner==1 => destination net is counterparty net


Parallel GPIO Profile
--------------------------------------------------------------------------------

The Parallel GPIO profile describes a set of CAN messages (reports)
to for performing I/O on 8-bit GPIO port.
It is designed to be similar to one of CAN Extender,
to allow for at least partially compatible software.

There are the following registers in the profile:
- PORT_OUT_MASK:    the mask for writes into PORT_OUT.
                    write only.
- PORT_OUT:         determines the pins driven by the port.

- PORT_IN_MASK:     the mask of bits in PORT_IN changed since the last report.
                    read only.
- PORT_IN:          contains the value that is read by the port.

- PORT_DIR:         determines the direction of the port pins (1=output, 0=input).
- PORT_CNF1:        reserved
- PORT_CNF2:        reserved
- PORT_CNF3:        reserved
- PORT_MODE0:       port mode bits
- PORT_MODE1:       port mode bits

If the port is configured for input, the bits in PORT_MODE1 and PORT_MODE0
are interpreted as follows:

- 00: changes on the pin do not generate notifications.
- 01: positive edge generates notifications.
- 10: negative edge generates notifications.
- 11: positive and negative edge generates notifications.

When a notification is generated, the corresponding bit in PORT_IN_MASK
is set.


There are the following fields in the profile ROM:
- PORT_DIR_MASK:    the mask of the bits of PORT_DIR that can be changed.


There are the following reports in the profile:

- PORT_OUT:
  - byte 0:         register PORT_OUT_MASK
  - byte 1:         register PORT_OUT

- PORT_IN:
  - byte 0:         register PORT_IN_MASK
  - byte 1:         register PORT_IN

- PORT_CONF:
  - byte 0:         register PORT_DIR
  - byte 1:         register PORT_CNF1
  - byte 2:         register PORT_CNF2
  - byte 3:         register PORT_CNF3
  - byte 4:         register PORT_MODE0
  - byte 5:         register PORT_MODE1

// Source code adopted from electronix.ru
// --------------------------------------

#include "cpu/avr/drivers/display/mt12864/bitblt.h"
#include "cpu/avr/drivers/display/mt12864/driver.h"

#ifndef min
#define min(a, b)	((a) < (b) ? (a) : (b))
#endif

#ifndef max
#define max(a, b)	((a) > (b) ? (a) : (b))
#endif


/*--------------------------------------------------------------------------------------------*/
/* ╨рчьхЁ√ яюы  фшёяых  т яшъёхырї.                                                           */
/*--------------------------------------------------------------------------------------------*/
#define   MAX_WIDTH     128
#define   MAX_HEIGHT    64

/*--------------------------------------------------------------------------------------------*/
/* Процедура вывода битового образа по заданным координатам.                                  */
/* Принимает:   координаты вывода изображения (графические),                                  */
/*              ширину и высоту изображения,                                                  */
/*              адрес таблицы с битовым образом во flash,                                     */
/*              байт признаков вывода изображения.                                            */
/* Возвращает:  ничего не возвращает.                                                         */
/*--------------------------------------------------------------------------------------------*/
void Draw_Bitmap(
    uint8_t X,
    uint8_t Y,
    uint8_t W,
    uint8_t H,
    prog_uint8_t *pData,
    uint8_t flags)
{
  // Буфер для постраничной обработки изображения.
  uint8_t buf[MAX_WIDTH];
  // Сразу не выводим, если координаты за пределами дисплея.
  if((X >= MAX_WIDTH) || (Y >= MAX_HEIGHT)) return;
  // Ширина изображения ограничивается вертикальной границей дисплея.
  uint8_t w = ((uint8_t)(X + W) < MAX_WIDTH) ? (W) : (MAX_WIDTH - X);
  // Цикл до завершения вывода всех строк изображения.
  uint8_t h = H;   // Счетчик числа еще не выведенных строк изображения.
  while(h > 0)
    {
      // Определим страницу видеопамяти ЖКИ, в которую будем выводить.
      // Не допускаем выход за пределы экрана.
      uint8_t page = Y >> 3;
      if(page >= 8) break;
      // Считаем содержимое текущей страницы видеопамяти.
      Read_Data_from_LCD_4(page, X, &buf[0], w);
      // Сформируем маску, накладываемую на считанное из ЖКИ изображение
      // и подсчитаем число выводимых в этом проходе битов.
      uint8_t mask = 0x00, n = 0;
      for(uint8_t i = 0; i < 8; i++)
         {
           mask >>= 1;
           if(((uint8_t)(((page * 8) + i)) >= Y) && ((uint8_t)(((page * 8) + i)) < (uint8_t)(Y + h)))
             {
               mask |= 0x80; n++;
             }
         }
      mask = ~mask;
      // Число выводимых в данном проходе строк не должно превышать
      // число битов до конца байта столбца изображения.
      if(((H - h) & 0x07) != 0) n = min(8 - ((H - h) & 0x07), n);
      // Накладываем на считанное изображение наше изображение.
      prog_uint8_t *p = pData + W * ((H - h) >> 3);
      for(uint8_t i = 0; i < w; i++)
         {
//           uint8_t data = *(p + i);
           uint8_t data = pgm_read_byte(p + i);
           // Если разрешено подчеркивание - подчеркиваем.
           if(((flags & DRAW_UNDERLINED) != 0) && ((h - n) <= 0)) data |= (1 << (n - 1));
           // Если разрешена инверсия - инвертируем.
           if((flags & DRAW_INVERTED) != 0) data = ~data;
           // Выравниваем по границе байта изображения дисплея.
           if((Y & 0x07) == 0) data >>= ((H - h) & 0x07);
           else             data <<= (Y & 0x07);
           // Накладываем изображение на считанное из дисплея.
           data &= ~mask;
           if((flags & DRAW_XOR) != 0) buf[i] ^= data;
           else                        buf[i] = (buf[i] & mask) | data;
         }
      // Записываем сформированное изображение обратно в память ЖКИ.
      Write_Data_to_LCD_4(page, X, &buf[0], w);
      // Переходим к следующей группе строк.
      h -= n; Y += n;
    }
  return;
}
